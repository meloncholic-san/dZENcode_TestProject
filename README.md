# dZENcode_TestProject
## SPA-приложение: Комментарии

### Ссылка на задеплоенный проект Versel: 
https://dzencode-test-project-front.vercel.app/

### Ссылка на задеплоенный API:
https://dzencode-testproject.onrender.com

Перейдя по ссылке на задеплоенный проект на Vercel, вы сможете полноценно использовать все функции и возможности приложения.
При первом рендере возможно 15 секунд задержки загрузки контента, это связано с отимизацией render.com и функцией простоя серверной части. После "пробуждения" серверной части в дальнейшем отклик будет без задержек.

### Запуск через Docker.yaml

 #### Клонируйте репозиторий
 #### Создайте .env файл в папке backend
Не забудьте указать корректные данные для подключения к базе данных и JWT. Пример подключения можно посмотреть в файле .env.example.

 #### Запустите проект
docker-compose up --build
Это поднимет два контейнера.
- frontend (React)
- backend (Express) + (PostgreSQL + Redis - облачно)
После сборки и запуска контейнеров:
- Frontend доступен по адресу: http://localhost:5173
- Backend API доступен по адресу: http://localhost:8080

#### В корне директории также есть диаграмма зависимостей Postgre моделей dZENcode_testProjectDB_diagram.mwb, поддерживается MySQL Workbench.

### Приложение построенно с помощью таких технологий, фреймворков:
Frontend: React, Redux Toolkit, Formik, Vite, yup, axios, lightbox, dompurify

Backend: Node.js, Express, PostgreSQL, Sequelize ORM, Multer, JWT auth, JOI schemas, multer, svg-captcha, WebSockets, Redis

База данных: PostgreSQL

Авторизация: JWT или Cookie-based сессии (переключается флагом) в .env

Docker: Поддержка docker-compose


### Отправка комментариев
Пользователь может отправить:

- Имя (только латиница и цифры)
- Email (валидный формат)
- Домашнюю страницу (опционально, формат URL)
- Текст сообщения (валидация и фильтрация тегов)
- CAPTCHA (svg-captcha)
- Файл (изображение или .txt), в последствии обрабатывается на сервер.

    Все данные валидируются на клиенте (Formik + Yup) и сервере (с помощью middleware ValidateBody, которое ожидает Joi схему для проверки req.body).

    Форма комментариев поддерживает ограниченный набор HTML-тегов, которые можно использовать для форматирования текста.
Разрешённые HTML-теги:
- <a href="" title=""></a>

- <code></code>

- <i></i>

- <strong></strong>

    Для защиты от XSS и вставки нежелательных скриптов используется библиотека DOMPurify.
При отправке комментария ввод пользователя проходит HTML-валидацию с помощью кастомной функции (isHtmlValid), которая:
- проверяет допустимость и корректность вложенности разрешённых тегов;
- отклоняет любые другие теги.
При отображении комментария в DOM применяется DOMPurify.sanitize(), чтобы гарантировать, что отрисуется только безопасный HTML:

    Пользователь может видеть предварительный просмотр отформатированного HTML во время ввода — предварительный просмотр также проходит через DOMPurify перед рендером.
В интерфейсе предусмотрены кнопки для вставки разрешённых тегов с автооборачиванием выделенного текста.

Также есть возможность предпросмотра img файла с помощью библиотеки another-lightbox.


### Отображение сообщений и архитектура клиентского дерева: 
Для загрузки сообщений используется Redux и action fetchComments.
При загрузке страницы клиент один раз получает от сервера список всех сообщений в плоском виде (flat-структура). Каждое сообщение содержит id и, если это ответ — parentId.
[
  { id: 1, parentId: null, ... },
  { id: 2, parentId: 1, ... },
  { id: 3, parentId: 2, ... },
  ...
]

    На клиенте с помощью useMemo() и вспомогательной функции buildTree() эти данные преобразуются в древовидную структуру (комментарии + вложенные ответы). 
Это дерево отображается рекурсивно с помощью компонента CommentsItem. Любой уровень вложенности комментариев поддерживается на клиенте благодаря рекурсивной отрисовке. 
    При создании комментария на сервере (в контроллере createMessageCtrl) используется текущий пользователь из req.user, полученный из middleware optionalAuth.
В запросе к базе через Sequelize для сообщения через include подтягиваются данные пользователя — поля name и avatarUrl из модели User (as: 'author').
Если автор не авторизован - тоесть, аноним, и нет связанного пользователя, то используется данные из полей name и email, переданных при создании комментария.
В итоге клиент получает комментарий уже с вложенным объектом author, что позволяет отображать имя и аватарку, как в корневых сообщениях, так и в ответах.

    Пагинация и сортировка реализованы на клиенте.
Пагинация применяется только к корневым комментариям (parentId === null), вложенные комментарии не разбиваются по страницам.
Поддерживаются:
- сортировка по name, email, createdAt;
- направление asc / desc.
WebSocket выступает как "триггер" для обновления. После успешного создания комментария сервер рассылает сообщение всем подключённым клиентам: "type": "new_comment", в следствии чего повтоно вызывается action fetchComments. 

### Это удобно и эффективно, но есть некоторые ограничение:
- Пагинация и сортировка реализованы на клиенте, а не на сервере. 
- Все сообщения отдаются сразу — неэффективно при большом объёме данных, но подходит на текущий момент.
- WebSocket сейчас рассылает обновления всем клиентам, независимо от их состояния и контекста.

### Моя идея для будущей реализации:
Если пользователь задал пагинацию и сортировку, то сервер не может слепо отправлять всем одни и те же данные по WebSocket — ведь у каждого клиента может быть: 
своя текущая страница, свой сортировочный столбец и направление по убыванию или возрастанию.
В таком случае - WebSocket будет служить как «триггер», а клиент сам будет делать fetch через API. Тоесть, когда на сервере что-то изменилось (например, добавлен комментарий), WebSocket только уведомляет, а клиент сам делает fetch с параметрами сортировки и пагинации, которые записаны у него в состоянии, например - Редукс. 
Тоесть, реализовать API вида: GET /messages?page=2&sortBy=name&sortOrder=asc, что перенесет логику построения дерева комментариев на сервер и будет отдавать уже сортированные и вложенные комментарии клиенту. Это гарантировано улучшит производительность при большом количестве сообщений.

### Сохранение в БД

    Все сообщения, отправляемые через форму, сохраняются в PostgreSQL с использованием Sequelize ORM.
Сообщения могут быть вложенными. Связи между сообщениями реализованы через parentId (рекурсивная модель). Каждое сообщение может иметь:
- parentId — ID сообщения-родителя.
- replies — ассоциация hasMany, для получения всех ответов.

    С помощью Middleware optionalAuth:
- Проверяет JWT-токен в заголовках Authorization или сессионный cookie.
- Если пользователь аутентифицирован, добавляет объект { id } в req.user.
Это позволяет контроллеру знать, кто создаёт комментарий, и связать его с пользователем в БД. 

### Кеширование Redis
    Все сообщения кешируются в Redis (key = all_messages) на 30 секунд. 
Данные кешируються для того чтобы уменьшить нагрузку на базу данных в случае частых запросов от клиента, например, при ререндерах компонентов.
Кеш сбрасывается после создания нового сообщения, для того чтобы не передавались устаревшие закешированные данные.
После успешного создания нового сообщения, оно отправляется всем подключённым клиентам через WebSocket:

### OOP и архитектура

    Проект построен с использованием архитектурного подхода MVC (Model-View-Controller) в сочетании с сервисной архитектурой, обеспечивающей чистую модульность и легкость масштабирования.
- Model (models/db) – взаимодействие с базой данных (через ORM), инкапсуляция бизнес-сущностей и логики хранения.
- Controller – обработка HTTP-запросов, валидация данных, формирование ответа, вызов соответствующих сервисов.
- Service – изолированные бизнес-функции, переиспользуемые в разных частях приложения. Позволяет держать контроллеры "тонкими".
- Middleware – промежуточная обработка (авторизация, обработка ошибок, верификация и др.).
- Routes – маршрутизация HTTP-запросов, привязка путей к контроллерам.
- Utils & Validation – утилиты, схемы валидации (Joi и пр.), загрузка и обработка файлов и другие вспомогательные модули.

    Система загрузки реализована с использованием multer и позволяет обрабатывать как изображения, так и текстовые файлы с дополнительной валидацией и безопасностью. 
Используется fileFilter, который проверяет MIME-тип и расширение. Запрещённые форматы отклоняются с ошибкой 400 Bad Request. Все изображения автоматически уменьшаются до макс. 320×240 пикселей с помощью sharp, что в дальнейшнм ускоряет загрузку на клиенте и снижает нагрузку на сеть.

Этоь пункт можно было б реализовать, например в помощью server Workers, которые бы отдельно работали над функцией обработки файлов, ускоряя сохранение сообщений и ответ для клиента, подставляя "заглушку", и уже после обработки догружая фактический файл, используя, например, WebSockets, 

    Текстовые файлы .txt проверяются на размер — максимум 100 КБ. Файлы, превышающие этот лимит, удаляются, и возвращается ошибка.
Если включена переменная окружения UPLOAD_TO_CLOUDINARY=true, изображения загружаются в Cloudinary.
Иначе файл сохраняется локально в папку uploads/messages/.
